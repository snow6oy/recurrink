#!/usr/bin/env python
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
import os
import sys
import argparse
import datetime 
import time
import random
import pprint
from model import ModelData, SvgModel
from model.init import Init
from block import PaletteMaker, TmpFile, BlockData, Make
from cell import CellData
from config import *
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
pmk     = PaletteMaker()
tf      = TmpFile()
md      = ModelData()
bd      = BlockData()
WORKDIR = config.directory['rinks']
PUBDIR  = config.directory['pubq']
PALDIR  = config.directory['palettes']
fnam    = md.pens()  # pal.friendlyPenNames()
pp      = pprint.PrettyPrinter(indent=2)
start_t = time.time()
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
''' get inputs from command line
'''
def main(args):
  parser = argparse.ArgumentParser(prog='recurrink')
  subparsers = parser.add_subparsers(dest='keyword', help='sub-command help')
  parser_b = subparsers.add_parser('build', help='build svg from config')
  parser_e = subparsers.add_parser('explode', help='stamp blocks on the grid')
  parser_k = subparsers.add_parser('clone', help='get copy of config')
  parser_i = subparsers.add_parser('init', help='generate config')
  parser_c = subparsers.add_parser('commit', help='write immutable entry to db')
  parser_p = subparsers.add_parser('publish', help='add release date to db')
  parser_d = subparsers.add_parser('delete', help='remove rink from db')
  parser_m = subparsers.add_parser('compare', help='compare palettes')
  parser_l = subparsers.add_parser('ls', help='list models or palettes')
  parser_r = subparsers.add_parser('read', help='get rink metadata')

  arg_d = { 'help': 'rink identifier with 32 random characters' }
  arg_f = {
    'help':'scale factor: 0.4-1.0', 
    'type':float, 'nargs':'?', 'const':1.0
  }
  arg_l = {
    'help':'draw lines or omit to paint',
    'action':argparse.BooleanOptionalAction
  }
  arg_m = { 'help':'name of base model' }
  arg_o = {
    'help':'clone celldata by default, else palette data',
    'nargs':'?', 'choices':['cell','pal', 'db2'], 'const':'cell'
  }
  arg_p = { 'help':'pen name used in GPLFILE and pens table' }
  arg_s = { 
    'help':'cell lengths: 18-90', 
    'nargs':'?', 'type':int, 'const':36
  }
  # 'required':True
  arg_v = {
    'help':'palette version',
    'type':int, 'choices':range(0, 99), 'metavar':'[0-99]'
  }
  arg_x = {
    'help':'exchange colours to -p as new svg',
    'action':argparse.BooleanOptionalAction
  }
  arg_z = {
    'help':'numof layers *3 or 2', 
    'metavar':'2-3', 'nargs':'?', 'const':3, 'type':int
  }

  parser_b.add_argument('-v', '--palver',   **arg_v)    # write as html
  parser_b.add_argument('-d', '--digest',   **arg_d)
  parser_b.add_argument('-m', '--model',    **arg_m)
  parser_b.add_argument('-s', '--size',     **arg_s)
  parser_b.add_argument('-f', '--factor',   **arg_f)
  parser_b.add_argument('-z', '--layer',    **arg_z)
  parser_b.add_argument('-l', '--line',     **arg_l)
  parser_b.add_argument('-x', '--exchange', **arg_x)

  parser_m.add_argument('-v', '--palver',   **arg_v)
  parser_m.add_argument('-d', '--digest',   **arg_d)
  #  required=True
  parser_c.add_argument('-m', '--model',    **arg_m) 
  parser_c.add_argument('-s', '--size',     **arg_s)
  parser_c.add_argument('-f', '--factor',   **arg_f)
  parser_c.add_argument('-x', '--exchange', **arg_x)
  parser_c.add_argument('-v', '--palver',   **arg_v)
  parser_c.add_argument('-d', '--digest',   **arg_d)
  parser_c.add_argument('-p', '--penam',    **arg_p)

  # klone :-)
  parser_k.add_argument('-d', '--digest',   **arg_d)
  parser_k.add_argument('-o', '--output',   **arg_o)
  parser_k.add_argument('-p', '--penam',    **arg_p)
  parser_k.add_argument('-v', '--palver',   **arg_v)

  parser_d.add_argument('-d', '--digest',   **arg_d)

  parser_e.add_argument('-s', '--size',     **arg_s)
  parser_e.add_argument('-f', '--factor',   **arg_f)
  parser_e.add_argument('-l', '--line',     **arg_l)
  parser_e.add_argument('-m', '--model',    **arg_m)
  parser_e.add_argument('-z', '--layer',    **arg_z)
  parser_e.add_argument('-x', '--exchange', **arg_x)

  parser_i.add_argument('-m', '--model',    **arg_m)
  parser_i.add_argument('-p', '--penam',    **arg_p)

  parser_l.add_argument('-o', '--output',   **arg_o)
  parser_p.add_argument('-d', '--digest',   **arg_d)
  parser_r.add_argument('-m', '--model',    **arg_m)
  parser_r.add_argument('-d', '--digest',   **arg_d)

  return parser.parse_args()
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
def compare(args):
  ''' compare palettes given ver and digest
      expect tmp/PALETTE.txt tmp/DIGEST.txt to exist already
  '''
  print(pmk.cmpPalettes(fnam[args.palver], args.digest))

def commit(args):
  ''' read config, write to database and return digest
      clean file system except for tmp/model.txt

    When both pal and digest are given remember to do this first
      export view using recurrink init -v --> /tmp/MODEL.txt
      export pal from using palette init -p

    When only pal then
      convert palette in tmpfile to sql INSERT but first manually 
      create tmpfile NEW_PAL.txt 
      add NEW_PAL to friendly_name
      use the index of config.friendly_name[] as arg
  '''
  pal = Palette()    # throws error but pal was assigned already???
  cd = CellData()
  if args.palver and args.digest and args.exchange: # only pens
    dig       = args.digest  # '180f1989f54ff03291ec31e164f2a79f'
    celldata  = cd.layers(args.digest)  #view.read(digest=dig) 
    ver       = bd.version(args.palver) 
    oc        = tf.getOldColors(args.digest)
    #pp.pprint(oc)
    colors    = bd.colors(args.palver)
    #pp.pprint(colors)
    uniqfill  = set([c[0] for c in colors])  # strip out penam
    #pp.pprint(uniqfill)
    nc        = pmk.setLookUp(uniqfill) # for search the new colour
    swp       = pmk.swapColors(oc, nc)
    for label, cell in celldata.items():
      layers = list()
      for z in cell:
        old_stroke   = z[3]
        new_layer    = list(z)
        new_layer[3] = swp[old_stroke]
        layers.append(tuple(new_layer))
      celldata[label] = layers  # update db colors 
    #pp.pprint(celldata)
    rinkdata    = list(bd.rinks(args.digest))
    rinkdata[2] = ver
    bd.rinks(args.digest, rinkdata)
    print(f'new ver {rinkdata[3]} updated {bd.count=}')
    cd.layers(args.digest, celldata)
    print(f'cell updates {cd.count=}')
  elif args.penam and args.palver:
    ''' create new color entries as bd.colours(ver, colors=list())
        entry in pens table should be made manually before
    '''
    gpldata = pmk.readInkscapePal(PALDIR, f'{args.penam}.gpl')
    bd.colors(args.palver, colors=gpldata)
    print(f'{bd.count=}')
    #pal.penNames(args.penam, gpldata)
  elif args.model and args.size and args.factor:
    mid      = md.model(name=args.model)
    pens     = md.pens()
    celldata = tf.readConf(args.model)
    metadata = tf.readConf(args.model, meta=True)
    if metadata['palette'] in pens:
      ver = pens.index(metadata['palette'])
    else:
      ver = 0
    tf.setDigest(celldata=celldata)
    print(f''' 
{tf.digest} 
{args.model=} {mid=}
{metadata['palette']} {ver=}, 
{args.size=} 
{args.factor=}''')
    if os.path.isdir(f"{WORKDIR}/{args.model}"):
      bd.rinks(tf.digest, [mid, ver, args.size, args.factor])
      if bd.count:
        response = f'{tf.digest=} ok'
        celldata = cd.dataV2(celldata)
        cd.layers(tf.digest, celldata=celldata)
        '''
        if os.path.isfile(f"tmp/{args.model}.svg"):
          svgname = f"{WORKDIR}/{args.model}/{tf.digest}.svg"
          os.rename(f"tmp/{args.model}.svg", svgname)
          os.symlink(f"{svgname}", f"{PUBDIR}/{tf.digest}.svg")
          response = svgname
        else:
          raise FileNotFoundError(f"{args.model}.svg not found in tmp")
        '''
      else:
        response = 'error adding rink'
    else:
      raise FileNotFoundError(f"{args.model} not found in {WORKDIR}")
    print(response)
  else: 
    print(f'''cannot commit missing args:
{args.model=}
{args.factor=}
{args.palver=} 
{args.penam=} 
{args.digest=} 
{args.exchange=}''')

def clone(args):
  ''' pull from db to create tmp/MODEL.txt from digest
  '''
  cd = CellData()
  rinkid, mid, ver, clen, factor, *dates = bd.rinks(args.digest)
  if args.output == 'pal' and args.digest: # export rink as palette
    uniq    = set()
    layers  = cd.layers(args.digest)
    pp.pprint(layers)
    for label, cell in layers.items():
      for z, row in enumerate(cell):
        #print(f'{label} {z} {row[3]}')
        uniq.add(row[3])
    tf.exportPalfile(args.digest, uniq) 
    print(f"palettes/{args.digest}.txt was written")
  elif args.output == 'pal' and args.penam: # e.g. uniball.gpl
    palette = pmk.readInkscapePal(PALDIR, f"{args.penam}.gpl")
    #pp.pprint(palette)
    tf.exportPalfile(args.penam, palette) 
    print(f"palettes/{args.penam}.txt was written from gplfile")
  elif args.output == 'pal' and args.palver: # export colors from db
    fn    = fnam[args.palver]
    palette = bd.colors(ver=args.palver)
    print(f"palettes/{fn}.txt was written from db")
  else:   # assume we want celldata
    rinkdata        = bd.rinks(args.digest)
    model, metadata = tf.rinkMeta(rinkdata)
    pens  = md.pens()

    if 1 <= ver < len(pens):
      penam = pens[ver]
    else:
      penam = None
    #print(f'{ver=} {penam=}')
    #pp.pprint(pens)
    # TODO remove this tf.cellData(rinkdata)
    celldata    = cd.layers(args.digest)  #view.read(digest=dig) 
    celldata    = cd.txDbv3Yaml(celldata)
    tf.writePretty(model, metadata, celldata)
    print(f"""
cloning {model}
with {len(celldata)} cells
palette {penam}""")

def delete(args):
  ''' if delete had no help text it would not be listed by argparse
  print(f'{args.digest=}')
  '''
  bd       = BlockData()
  rinkdata = bd.rinks(args.digest) 
  if len(rinkdata):
    bd.rinksDelete(args.digest) 
    ''' review this and commit
    model = md.model(mid=rinkdata[1])
    if os.path.isfile(f'{PUBDIR}/{args.digest}.svg'):
      os.unlink(f'{PUBDIR}/{args.digest}.svg')
    if os.path.isfile(f'{WORKDIR}/{model}/{args.digest}.svg'):
      os.unlink(f'{WORKDIR}/{model}/{args.digest}.svg')
      print(f'{args.digest} deleted ok') # success
    else: raise FileNotFoundError(f'SVG not deleted {model}/{args.digest}')
    '''
  else: raise ValueError(f'nothing named {args.digest} in database')

def explode(args):
  ''' assumptions: gridsize is A3 (297 x 420 mm) 
      image is square: with margins grid approximate 270 x 270
      numbers of cells defined by cell length which prefers to be divisible by 3
      to ensure whole numbers: clen should be: 9 18 27 36 45 54 90 ..
  '''
  if args.factor: svglin = SvgModel(args.size, args.factor)
  else:           svglin = SvgModel(args.size)
  celldata   = tf.readConf(args.model)
  ver        = fnam.index(tf.VERSION)
  if args.model == 'minkscape': # default model
    positions = config.positions
    penam     = config.penam[2]  # pen names for htmstart pal
    block     = Make(args.size, linear=bool(args.line), pen_names=penam)
  else:                         # TODO source positions from model
    mid       = md.model(name=args.model)
    positions = md.blocks(mid)
    colors    = bd.colors(ver)
    ''' are these two lines business logic?
    if yes then put in build.py
    else put in data.py
    '''
    penam     = dict()
    for k, v in colors: penam[k] = v
    block     = Make(args.size, linear=bool(args.line), pen_names=penam)

  block.walk(positions, celldata, z=args.layer)
  block.hydrateGrid()
  svglin.explode(block)
  svglin.render(args.model, line=bool(args.line))
  print(f'tmp/{args.model}.svg was exploded')

def init(args):
  ''' pull a palette from db and write to tmpfile
      generate an editable config file 
  '''
  cd = CellData()
  init       = Init()
  model, pen = init.setInput(args.model, args.penam)
  src, data  = init.generate(model, pen)
  newver     = init.ver + 7
  tf.setVersion(newver)
  tf.writePretty(model, data)
  print(f'''generated {model} with {len(data.keys())} cells
using {pen} from source: {src} 
''')


def ls(args):
  ''' list from db or config
  '''
  if args.output == 'pal': 
    [print(f"{i}\t{name}") for i, name in enumerate(fnam)]
  else:
    print('working on it') 
    # print(md.stats())

# TODO rinksUpdate has to accept pubdate as well as ver
def publish(args):
  ''' used by reith to update pubdate

      2024-01-27 22:26:12
  '''
  rinkdata = list(bd.rinks(args.digest))
  if len(rinkdata) == 7:
    rinkdata[6] = '{d:%Y-%m-%d %H:%M:%S}'.format(d=datetime.datetime.now())
    bd.rinks(args.digest, rinkdata)
    print(f'{rinkdata[6]} updated {bd.count=}')

def read(args):
  #bd = BlockData()
  if args.model:
    mid       = md.model(name=args.model)
    blocksize = md.setBlocksize(mid)
    print(bd.prettyPrint(args.model, blocksize[0], blocksize[1]))
  elif(args.digest):  # reith is consumer
    rinkdata = bd.rinks(args.digest)
    print("""
-------+----------
 model | {r[1]}
palver | {r[2]}
  size | {r[3][0]} x {r[3][1]}
factor | {r[4]}
create | {r[5]:%Y-%m-%d}
   pub | {r[6]:%Y-%m-%d}""".format(r=rinkdata))
  else:
    print('que?')

def build(args):
  ''' generate an SVG from tmpfile or an HTML palette
  '''
  bd = BlockData()
  if args.palver:
    ''' run init -p PENAM first
    '''
    fn      = md.pens(ver=args.palver)
    palette = tf.importPalfile(fn)
    svgpal.render(fn, palette)
    print(f"palettes/{fn}.html was written")
  elif args.digest:
    ''' run clone -d DIGEST first
        but why build a color chart for a rink
        color charts should be for pens
    '''
    fn      = args.digest
    palette = tf.importPalfile(fn)
    svgpal.render(fn, palette)
    print(f"palettes/{fn}.html was written")
  elif args.model and args.size and args.factor:
    svglin    = SvgModel(args.size, args.factor)

    if args.model == 'minkscape': # default model
      positions = config.positions
    else: # TODO get positions from tf.positions() after readConf
      mid       = md.model(name=args.model)
      positions = md.blocks(mid)

    metadata  = tf.readConf(args.model, meta=True)    
    celldata  = tf.readConf(args.model)
    #pp.pprint(celldata.keys())
    penam     = metadata['palette']  # fnam.index(tf.VERSION)
    pens      = md.pens()
    ver       = pens.index(penam)
    colors    = bd.colors(ver)
    print(f'{penam=} {ver=}')
    ''' are these two lines business logic?
    if yes then put in build.py
    else put in data.py
    '''
    penam     = dict()
    for k, v in colors: penam[k] = v

    uniq      = list(penam.keys())
    # TODO add color validation to Pydantic
    #old_ver = ver + 7
    #cd = CellData(ver=old_ver)
    pal     = Palette(ver=ver)
    pal.uniqfill = uniq
    [pal.validate(label, cell) for label, cell in celldata.items()]

    block     = Make(args.size, linear=bool(args.line), pen_names=penam)
    block.walk(positions, celldata, z=args.layer)

    svgfile   = args.model
    svgfile  += '_line' if bool(args.line) else '_box'
    block.hydrateGrid()
    svglin.build(block)
    svglin.render(svgfile, line=bool(args.line))
    print(f'tmp/{svgfile}.svg was built with pal {fnam[ver]}')
  else:
    raise Warning(f'''missing argument
{args.palver=} 
{args.digest=}
{args.model=} 
{args.size=}
{args.factor=}
''')

if __name__ == "__main__":
  args = main(sys.argv[1:])
  if   args.keyword == 'compare': compare(args)
  elif args.keyword == 'commit':  commit(args)
  elif args.keyword == 'clone':   clone(args)
  elif args.keyword == 'delete':  delete(args)
  elif args.keyword == 'explode': explode(args)
  elif args.keyword == 'init':    init(args)
  elif args.keyword == 'ls':      ls(args)
  elif args.keyword == 'publish': publish(args)
  elif args.keyword == 'read':    read(args)
  elif args.keyword == 'build':   build(args)
  else:
    print(f'usage: {sys.argv[0]} --help')
    sys.exit(1)
  print(f"--- {round(time.time() - start_t, 3)} seconds ---")

'''
the
end
'''
