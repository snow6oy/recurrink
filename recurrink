#!/usr/bin/env python3
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
import os
import sys
import argparse
import time
import random
import pprint
from model import ModelData, SvgModel, SvgPalette, SvgWriter
from block import PaletteMaker, TmpFile, Views, BlockData, Make
from cell import Palette
from config import *
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
modl    = ModelData()
pal     = Palette()
pmk     = PaletteMaker()
svgpal  = SvgPalette()
tf      = TmpFile()
view    = Views()
WORKDIR = config.directory['rinks']
PUBDIR  = config.directory['pubq']
PALDIR  = config.directory['palettes']
fnam    = pal.friendlyPenNames()
pp      = pprint.PrettyPrinter(indent=2)
start_t = time.time()
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
''' get inputs from command line
'''
def main(args):
  parser = argparse.ArgumentParser(prog='recurrink')
  subparsers = parser.add_subparsers(dest='keyword', help='sub-command help')
  parser_b = subparsers.add_parser('build', help='build svg from config')
  parser_k = subparsers.add_parser('clone', help='get copy of config')
  parser_c = subparsers.add_parser('commit', help='write immutable entry to db')
  parser_m = subparsers.add_parser('compare', help='compare palettes')
  parser_d = subparsers.add_parser('delete', help='remove rink from db')
  parser_e = subparsers.add_parser('explode', help='stamp blocks on the grid')
  parser_i = subparsers.add_parser('init', help='generate config')
  parser_l = subparsers.add_parser('ls', help='list models or palettes')
  parser_p = subparsers.add_parser('publish', help='add release date to db')
  parser_r = subparsers.add_parser('read', help='get rink metadata')

  parser_b.add_argument(
    '-p', '--palette', 
    help='palette version to write as html',
    type=int, choices=range(0, 99), metavar='[0-99]'
  )
  parser_b.add_argument(
    '-d', '--digest', 
    help='palette from rink to write as svg'
  )
  parser_b.add_argument(
    '-m', '--model', 
    help='name of model to build'
  )
  parser_b.add_argument(
    "-s", "--size", 
    help='cell lengths: 18-40', 
    nargs='?', type=int, const=18
  )
  parser_b.add_argument(
    "-f", "--factor", 
    help='scale factor: 0.4-1.0', 
    type=float, nargs='?', const=1.0
  )
  parser_b.add_argument(
    '-z', '--layer',  
    help='numof layers *3 or 2', 
    metavar='2-3', nargs='?', const=3, type=int
  )
  parser_b.add_argument(
    '-l', '--line',  
    help='draw lines or omit to paint',
    action=argparse.BooleanOptionalAction
  )
  parser_b.add_argument(
    '-x', '--exchange',  
    help='exchange colours to -p as new svg',
    action=argparse.BooleanOptionalAction
  )
  parser_m.add_argument(
    "-p", "--palette", 
    help='read palette from version in db', 
    type=int, choices=range(0, 99), metavar='[0-99]', required=True
  )
  parser_m.add_argument(
    '-d', '--digest', 
    help='read palette from rink in tmpfile', 
    required=True
  )
  parser_c.add_argument( 
    "-a", "--author", 
    choices=['human', 'machine'], nargs='?', const='human'
  )
  parser_c.add_argument(
    "-m", "--model", 
    help="name of model to commit"
  ) 
  parser_c.add_argument(
    "-s", "--size", 
    help='cell lengths: 18-40', 
    nargs='?', type=int
  )
  parser_c.add_argument(
    '-x', '--exchange',  
    help='exchange colours to -p in db',
    action=argparse.BooleanOptionalAction
  )
  parser_c.add_argument(
    "-p", "--palette", 
    help='new palette to create', 
    type=int, choices=range(0, 99), metavar='[0-99]'
  )
  parser_c.add_argument(
    '-d', '--digest', 
    help='swap rink to use palette'
  )
  parser_c.add_argument(
    "-i", "--inkpal", 
    help='Insert GPLFILE to pens table'
  )
  parser_k.add_argument(
    '-d', '--digest', 
    help='rink to clone', required=True
  )
  parser_k.add_argument(
    '-o', '--output', 
    help='clone celldata by default, else palette data',
    nargs='?', choices=['cell','pal'], const='cell',
  )
  parser_d.add_argument(
    '-d', '--digest', 
    help='rink to remove from db', 
    required=True
  )
  parser_e.add_argument(
    "-s", "--size", 
    help='cell lengths: 18-40', 
    type=int, required=True
  )
  parser_e.add_argument(
    "-f", "--factor", 
    help='scale factor: 0.4-1.0', 
    nargs='?', const=1.0, type=float
  )
  parser_e.add_argument(
    '-l', '--line',  
    help='output for plotter', 
    action=argparse.BooleanOptionalAction
  )
  parser_e.add_argument(
    '-m', '--model', 
    help='model to be exploded', 
    nargs='?', const='minkscape', required=True
  )
  parser_e.add_argument(
    '-z', '--layer',  
    help='numof layers *3 or 2', 
    nargs='?', const=3, type=int
  )
  parser_e.add_argument(
    '-x', '--exchange',  
    help='exchange colours to -p and write db',
    action=argparse.BooleanOptionalAction
  )
  parser_i.add_argument(
    '-m', '--model', 
    help='randomly generate conf for model'
  )
  parser_i.add_argument(
    "-p", "--palette", 
    help='palette version to initialise',
    type=int, choices=range(0, 99), metavar='[0-99]'
  )
  parser_i.add_argument(
    "-i", "--inkpal", 
    help='GPL source to generate palette'
  )
  parser_l.add_argument(
    "-o", "--output", 
    help='list pal or model by default',
    choices=['model','pal'], const='model', nargs='?' 
  )
  parser_p.add_argument(
    '-d', '--digest', 
    help='rink to mark as released', 
    required=True
  )
  
  parser_r.add_argument(
    '-m', '--model', 
    help='name of base model'
  )
  parser_r.add_argument(
    '-d', '--digest', 
    help='hex name with 32 char'
  )
  return parser.parse_args()
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
def compare(args):
  ''' compare palettes given ver and digest
      expect tmp/PALETTE.txt tmp/DIGEST.txt to exist already
  '''
  print(pmk.cmpPalettes(fnam[args.palette], args.digest))

def commit(args):
  ''' read config, write to database and return digest
      clean file system except for tmp/model.txt

    When both pal and digest are given remember to do this first
      export view using recurrink init -v --> /tmp/MODEL.txt
      export pal from using palette init -p

    When only pal then
      convert palette in tmpfile to sql INSERT but first manually 
      create tmpfile NEW_PAL.txt 
      add NEW_PAL to friendly_name
      use the index of config.friendly_name[] as arg
  '''
  pal = Palette()    # throws error but pal was assigned already???
  if args.palette and args.digest and args.exchange:
    dig       = args.digest  # '180f1989f54ff03291ec31e164f2a79f'
    celldata  = view.read(digest=dig) 
    ver       = args.palette # use onlyi pen pals 8..12 please
    oc        = tf.getOldColors(dig)
    pal.loadPalette(ver=ver)     # merge fg bg stroke into uniqfill 
    nc        = pmk.setLookUp(pal.uniqfill) # for search the new colour
    swp       = pmk.swapColors(oc, nc)
    pids      = pal.updatePids(ver, swp, celldata)
    rownum    = pal.swapPalette(pids, ver, dig)
    rownum   += view.updateSids(ver, dig, swp, celldata) # {'a': 309, 'b': 310
    print(f'{ver} {dig} {rownum} updates')
  elif args.palette and args.digest:
    model      = view.read_meta(args.digest)[0]
    celldata   = tf.read(model, output=list())
    numupdated = pal.swap_palette(celldata, ver, digest)
    print(f"""
update {numupdated} view 
swapping {args.digest} to palette {fnam[args.palette]}""")
  elif args.palette:
    txtpal          = tf.importPalfile(fnam[args.palette])
    missing_colours = pal.colour_check(txtpal)
    if len(missing_colours): # add any new colours 
      pal.create_colours(missing_colours)
      print(f"{len(missing_colours)} new colours ")
    dbpal   = pal.read_palette(args.palette)
    new_pal = pmk.makeUnique(args.palette, dbpal, txtpal)
    [pal.createPaletteEntry(n) for n in new_pal]
    print(f"{len(new_pal)} new entries")
  elif args.inkpal:
    gpldata = pmk.readInkscapePal(PALDIR, f'{args.inkpal}.gpl')
    pal.penNames(args.inkpal, gpldata)
  elif args.author and args.model and args.size:
    celldata = tf.readConf(args.model)
    metadata = tf.readConf(args.model, meta=True)
    pal      = metadata['palette']
    ver      = fnam.index(pal)
    lc       = -1  # TODO colournum should have a real value
    tf.setDigest(celldata=celldata)
    #print(f''' {tf.digest} {len(celldata.keys())} {args.model=} {args.author=} {ver=}, {size=} colournum {lc}''')
    if os.path.isdir(f"{WORKDIR}/{args.model}"):
      if view.create(
        tf.digest, celldata, model=args.model, author=args.author, 
        ver=ver, scale=args.factor, colournum=lc
      ):
        if os.path.isfile(f"tmp/{args.model}.svg"):
          svgname = f"{WORKDIR}/{args.model}/{tf.digest}.svg"
          os.rename(f"tmp/{args.model}.svg", svgname)
          os.symlink(f"{svgname}", f"{PUBDIR}/{tf.digest}.svg")
          response = svgname
        else:
          raise FileNotFoundError(f"{args.model}.svg not found in tmp")
      else:
        response = 'unknown error'
    else:
      raise FileNotFoundError(f"{args.model} not found in {WORKDIR}")
    print(response)
  else: 
    print(f'''cannot commit missing args:
{args.model=}
{args.author=}
{args.palette=} 
{args.inkpal=} 
{args.digest=} 
{args.exchange=}''')

def clone(args):
  ''' pull from db to create tmp/MODEL.txt from digest
  '''
  model, author, scale, ver = view.readMeta(digest=args.digest)
  if args.output == 'pal': # export view as palette
    palette = set(pal.read_view(args.digest))
    print(palette)
    tf.exportPalfile(args.digest, palette) 
    print(f"palettes/{args.digest}.txt was written")
  else:   # assume we want celldata
    celldata  = view.read(digest=args.digest) #, output=list())
    #tf.conf(model, fnam[ver]) # conf state is a symlink
    tf.setVersion(ver)
    tf.write(model, celldata)
    print(f"""
cloning {model}
with {len(celldata)} cells
palette {fnam[ver]}""")

def delete(args):
  # as delete has no help text it is not listed by argparse
  print(f'{args.digest=}')
  ''' both svg and view must exist for the delete to succeed
      4e3e83e969f2b41bf47fda2ec430a8f8 
  '''
  viewdata = view.readMeta(args.digest)
  if len(viewdata):
    view.delete(args.digest) 
    model = viewdata[0]
    if os.path.isfile(f'{PUBDIR}/{args.digest}.svg'):
      os.unlink(f'{PUBDIR}/{args.digest}.svg')
    if os.path.isfile(f'{WORKDIR}/{model}/{args.digest}.svg'):
      os.unlink(f'{WORKDIR}/{model}/{args.digest}.svg')
      print(f'{args.digest} deleted ok') # success
    else: raise FileNotFoundError(f'SVG not deleted {model}/{args.digest}')
  else: raise ValueError(f'nothing named {args.digest} in database')

def explode(args):
  ''' assumptions: gridsize is A3 (297 x 420 mm) 
      image is square: with margins grid approximate 270 x 270
      numbers of cells defined by cell length which prefers to be divisible by 3
      to ensure whole numbers: clen should be: 9 18 27 36 45 54 90 ..
  '''
  if args.factor: svglin = SvgModel(args.size, args.factor)
  else:           svglin = SvgModel(args.size)
  celldata   = tf.readConf(args.model)
  ver        = fnam.index(tf.VERSION)
  if args.model == 'minkscape': # default model
    positions = config.positions
    penam     = config.penam[2]  # pen names for htmstart pal
    block     = Make(args.size, linear=bool(args.line), pen_names=penam)
  else:                         # TODO source positions from model
    bd        = BlockData(args.model)
    positions = bd.readPositions(args.model)
    penam     = bd.penNames(ver)
    block     = Make(args.size, linear=bool(args.line), pen_names=penam)

  block.walk(positions, celldata, z=args.layer)
  block.hydrateGrid()
  svglin.explode(block)
  svglin.render(args.model, line=bool(args.line))
  print(f'tmp/{args.model}.svg was exploded')

def init(args):
  ''' pull a palette from db and write to tmpfile
      generate an editable config file 
  '''
  if args.inkpal: # e.g. uniball.gpl
    palette = pmk.inkscapePal(PALDIR, f"{args.inkpal}.gpl")
    tf.exportPalfile(args.inkpal, palette) 
    print(f"palettes/{args.inkpal}.txt was written")
  elif args.palette in range(99) and args.model:
    _model, src, celldata = view.generate(model=args.model, ver=args.palette)
    tf.conf(args.model, fnam[args.palette]) # conf state is a symlink
    celldata = tf.convertToList(celldata) # become a list before writing
    tf.write(args.model, celldata)
    print(f"""
initialising {args.model} with {len(celldata)} cells from {src}
palette {fnam[args.palette]}""")
  elif args.palette in range(99): # export from palette table
    fn    = fnam[args.palette]
    pal.loadPalette(ver=args.palette)
    #pp.pprint(pal.palette)
    palette = pal.palette # keep order so relations are grouped
    tf.exportPalfile(fn, palette) 
    print(f"{fn}.txt was written")
  else:
    ''' randomly generate conf/MODEL.yaml and palette
    '''
    ver                  = tf.setVersion(ver=args.palette)
    model, src, celldata = view.generate(model=args.model, ver=ver)
    tf.write(model, celldata)
    print(f"""
initialising {model} with {len(celldata)} cells from {src}
palette {fnam[ver]}""")

def ls(args):
  ''' list from db or config
  '''
  if args.output == 'pal': 
    [print(f"{i}\t{name}") for i, name in enumerate(fnam)]
  else: print(modl.stats())

def publish(args):
  ''' used by reith to update pubdate
  '''
  view.update(d)
  print(f"updated ok")

def read(args):
  if args.model:
    bd        = BlockData(args.model)
    blocksize = modl.read(model=args.model)[2]
    print(bd.prettyPrint(args.model, blocksize[0], blocksize[1]))
  else:  # reith is consumer
    v = view.readMeta(digest=args.digest)
    print(' '.join(v[:2]))

def build(args):
  ''' generate an SVG from tmpfile or an HTML palette
  '''
  if args.palette and args.digest and args.exchange:
    dig       = args.digest  # '180f1989f54ff03291ec31e164f2a79f'
    celldata  = view.read(digest=dig) 
    model     = view.readMeta(dig)[0] #Â model auth scale ver
    bd        = BlockData(model)
    positions = bd.readPositions(model)
    ver       = args.palette # use onlyi pen pals 8..12 please
    tf.setVersion(ver)
    oc        = tf.getOldColors(dig)
    pal.loadPalette(ver=ver)     # merge fg bg stroke into uniqfill 
    nc        = pmk.setLookUp(pal.uniqfill) # for search the new colour
    swp       = pmk.swapColors(oc, nc)
    print(f'''{len(oc)} to swap
{len(nc)} to search
''')
    pp.pprint(swp)
    celldata  = pmk.updateCells(celldata, swp)
    tf.write(model, celldata)   # write new colors to conf/palswap.yaml
    celldata  = tf.readConf(model) # dubble write to reformat celldata :sob:
    view.validate(celldata, ver=ver)
    svgfile   = model + '_exchange'
    svg       = SvgModel(18) # size of preview palswap.svg
    block     = Make(18, linear=False)
    # start to build
    block.walk(positions, celldata)
    block.hydrateGrid()
    svg.build(block)
    svg.render(svgfile, line=False)
    print(f'tmp/{svgfile}.svg was built')
  elif args.palette:
    fn      = fnam[args.palette]
    palette = tf.importPalfile(fn)
    svgpal.render(fn, palette)
    print(f"palettes/{fn}.html was written")
  elif args.digest:
    fn      = args.digest
    palette = tf.importPalfile(fn)
    svgpal.render(fn, palette)
    print(f"palettes/{fn}.html was written")
  elif args.model and args.size and args.factor:
    svglin    = SvgModel(args.size, args.factor)

    if args.model == 'minkscape': # default model
      positions = config.positions
    else: # TODO get positions from tf.positions() after readConf
      bd        = BlockData(args.model)
      positions = bd.readPositions(args.model)
    
    celldata  = tf.readConf(args.model)
    ver       = fnam.index(tf.VERSION)
    penam     = bd.penNames(ver)
    view.validate(celldata, ver=ver)
    block     = Make(args.size, linear=bool(args.line), pen_names=penam)
    block.walk(positions, celldata, z=args.layer)

    svgfile   = args.model
    svgfile  += '_line' if bool(args.line) else '_box'
    block.hydrateGrid()
    svglin.build(block)
    svglin.render(svgfile, line=bool(args.line))
    print(f'tmp/{svgfile}.svg was built with pal {fnam[ver]}')
  else:
    raise Warning(f'''missing argument
{args.palette=} 
{args.digest=}
{args.model=} 
{args.size=}
{args.factor=}
''')

if __name__ == "__main__":
  args = main(sys.argv[1:])
  if   args.keyword == 'compare': compare(args)
  elif args.keyword == 'commit':  commit(args)
  elif args.keyword == 'clone':   clone(args)
  elif args.keyword == 'delete':  delete(args)
  elif args.keyword == 'explode': explode(args)
  elif args.keyword == 'init':    init(args)
  elif args.keyword == 'ls':      ls(args)
  elif args.keyword == 'publish': publish(args)
  elif args.keyword == 'read':    read(args)
  elif args.keyword == 'build':   build(args)
  else:
    print(f'usage: {sys.argv[0]} --help')
    sys.exit(1)
  print(f"--- {round(time.time() - start_t, 3)} seconds ---")

'''
the
end
'''
