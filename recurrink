#!/usr/bin/env python3
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
import os
import argparse
import random
import pprint
from model import ModelData, Svg, SvgPalette, SvgLinear
from block import PaletteMaker, TmpFile, Views, BlockData, Make
from cell import Palette
from config import *
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
''' get inputs from command line
'''
parser = argparse.ArgumentParser(prog='recurrink')
subparsers = parser.add_subparsers(dest='keyword', help='sub-command help')

parser_b = subparsers.add_parser('build', help='build svg from config')
parser_b.add_argument(
  '-p', '--palette', type=int, choices=range(0, 99), metavar='[0-99]',
  help='palette version to write as svg' 
)
parser_b.add_argument('-d', '--digest', help='palette from rink to write as svg')
parser_b.add_argument('-m', '--model', help='name of model to build')
parser_b.add_argument(
  "-s", "--size", help='cell length', nargs='?', type=int, 
  choices=[9,18,27,45,54,90], const=9 
)
parser_b.add_argument(
  '-l', '--line',  help='output for plotter', 
  action=argparse.BooleanOptionalAction
)

parser_m = subparsers.add_parser(
  'compare', help='compare palettes: tmpfile to db'
)
parser_m.add_argument(
  "-p", "--palette", help='read palette from version in db', type=int, 
  choices=range(0, 99), metavar='[0-99]', required=True
)
parser_m.add_argument(
  '-d', '--digest', help='read palette from rink in tmpfile', required=True
)

parser_c = subparsers.add_parser('commit', help='write immutable entry to db')
parser_c.add_argument( 
  "-a", "--author", choices=['human', 'machine'], nargs='?', const='human'
)
parser_c.add_argument("-m", "--model", help="name of model to commit") 
parser_c.add_argument(
  "-s", "--size", help='cell length', nargs='?', type=int, 
  choices=[9,18,27,45,54,90], const=9, required=True
)
parser_c.add_argument(
  "-p", "--palette", help='new palette to create', type=int, 
  choices=range(0, 99), metavar='[0-99]'  #, required=True
)
parser_c.add_argument('-d', '--digest', help='swap rink to use palette')
parser_c.add_argument("-i", "--inkpal", help='Insert GPLFILE to pens table')

parser_k = subparsers.add_parser('clone', help='get copy of config')
parser_k.add_argument('-d', '--digest', help='rink to clone', required=True)
parser_k.add_argument(
  '-o', '--output', nargs='?', choices=['cell','pal'], const='cell',
  help='clone celldata by default, else palette data'
)

parser_d = subparsers.add_parser('delete')
parser_d.add_argument(
  '-d', '--digest', help='rink to remove from db', required=True
)

parser_e = subparsers.add_parser(
  'explode', help='stamp a block across the grid'
)
parser_e.add_argument(
  "-s", "--size", help='cell length', nargs='?', 
  type=int, choices=[9,18,27,45,54,90], const=9, required=True
)
parser_e.add_argument(
  '-l', '--line',  help='output for plotter', 
  action=argparse.BooleanOptionalAction
)
parser_e.add_argument(
  '-m', '--model', help='model to be exploded', 
  nargs='?', const='minkscape', required=True
)

parser_i = subparsers.add_parser('init', help='set config to create new image')
parser_i.add_argument('-m', '--model', help='randomly generate conf for model')
parser_i.add_argument(
  "-p", "--palette", type=int, choices=range(0, 99), metavar='[0-99]',
  help='palette version to initialise'
)
parser_i.add_argument("-i", "--inkpal", help='GPL source to generate palette')

parser_l = subparsers.add_parser('ls', help='list models or palettes')
parser_l.add_argument(
  "-o", "--output", choices=['model','pal'], const='model', nargs='?', 
  help='model by default'
)

parser_p = subparsers.add_parser('publish', help='add release date to db')
parser_p.add_argument(
  '-d', '--digest', help='rink to mark as released', required=True
)

parser_r = subparsers.add_parser('read', help='get rink metadata')
parser_r.add_argument('-m', '--model', help='name of base model')
parser_r.add_argument('-d', '--digest', help='hex name with 32 char')
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
args    = parser.parse_args()
modl    = ModelData()
pal     = Palette()
pmk     = PaletteMaker()
svg     = Svg()
svgpal  = SvgPalette()
tf      = TmpFile()
view    = Views()
WORKDIR = config.directory['rinks']
PUBDIR  = config.directory['pubq']
PALDIR  = config.directory['palettes']
fnam    = config.friendly_name  # list of palette names
pp      = pprint.PrettyPrinter(indent=2)
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
if (args.keyword == 'compare'):
  ''' compare palettes given ver and digest
      expect tmp/PALETTE.txt tmp/DIGEST.txt to exist already
  '''
  print(f'{args.palette=} {args.digest=}')
  print(pmk.cmpPalettes(fnam[args.palette], args.digest))

elif (args.keyword == 'commit'):
  ''' read config, write to database and return digest
      clean file system except for tmp/model.txt

    When both pal and digest are given remember to do this first
      export view using recurrink init -v --> /tmp/MODEL.txt
      export pal from using palette init -p

    When only pal then
      convert palette in tmpfile to sql INSERT but first manually 
      create tmpfile NEW_PAL.txt 
      add NEW_PAL to friendly_name
      use the index of config.friendly_name[] as arg
  '''
  print(f'{args.author=} {args.size=} {args.palette=} {args.digest=}')
  if args.palette and args.digest:
    model      = view.read_meta(args.digest)[0]
    celldata   = tf.read(model, output=list())
    numupdated = pal.swap_palette(celldata, ver, digest)
    print(f"""
update {numupdated} view 
swapping {args.digest} to palette {fnam[args.palette]}""")
  elif args.palette:
    palette         = tf.importPalfile(fnam[args.palette])
    missing_colours = pmk.colour_check(pal, palette)
    if len(missing_colours): # add any new colours 
      pal.create_colours(missing_colours)
      print(f"{len(missing_colours)} new colours ")
    pal.read_palette(args.palette)
    new_pal = pmk.makeUnique(args.palette, pal, palette)
    print(f"{len(new_pal)} new entries")
  elif args.inkpal:
    gpldata = pmk.readInkscapePal(PALDIR, f'{args.inkpal}.gpl')
    pal.penNames(args.inkpal, gpldata)

  elif args.author and args.model:
    celldata = tf.readConf(args.model)
    metadata = tf.readConf(args.model, meta=True)
    pal      = metadata['palette']
    ver      = fnam.index(pal)
    size     = args.size / 10  # make it fit scale type in db
    lc       = -1  # TODO colournum should have a real value
    tf.setDigest(celldata=celldata)
    #print(f''' {tf.digest} {len(celldata.keys())} {args.model=} {args.author=} {ver=}, {size=} colournum {lc}''')
    if os.path.isdir(f"{WORKDIR}/{args.model}"):
      if view.create(
        tf.digest, celldata, model=args.model, author=args.author, 
        ver=ver, scale=size, colournum=lc
      ):
        if os.path.isfile(f"tmp/{args.model}.svg"):
          svgname = f"{WORKDIR}/{args.model}/{tf.digest}.svg"
          os.rename(f"tmp/{args.model}.svg", svgname)
          os.symlink(f"{svgname}", f"{PUBDIR}/{tf.digest}.svg")
          response = svgname
        else:
          raise FileNotFoundError(f"{args.model}.svg not found in tmp")
      else:
        response = 'unknown error'
    else:
      raise FileNotFoundError(f"{args.model} not found in {WORKDIR}")
    print(response)
  else: print("cannot commit: missing model, author or palette")

elif (args.keyword == 'clone'):
  ''' pull from db to create tmp/MODEL.txt from digest
  '''
  print(f'{args.digest=} {args.output=}')
  model, author, scale, ver = view.readMeta(digest=args.digest)
  if args.output == 'pal': # export view as palette
    palette = set(pal.read_view(args.digest))
    tf.exportPalfile(args.digest, palette) 
    print(f"tmp/{args.digest}.txt was written")
  else:   # assume we want celldata
    celldata  = view.read(digest=args.digest) #, output=list())
    #tf.conf(model, fnam[ver]) # conf state is a symlink
    tf.write(model, celldata)
    print(f"""
cloning {model}
with {len(celldata)} cells
palette {fnam[ver]}""")

elif (args.keyword == 'delete'): 
  # as delete has no help text it is not listed by argparse
  print(f'{args.digest=}')
  ''' both svg and view must exist for the delete to succeed
      4e3e83e969f2b41bf47fda2ec430a8f8 
  '''
  viewdata = view.readMeta(args.digest)
  if len(viewdata):
    view.delete(args.digest) 
    model = viewdata[0]
    if os.path.isfile(f'{PUBDIR}/{args.digest}.svg'):
      os.unlink(f'{PUBDIR}/{args.digest}.svg')
    if os.path.isfile(f'{WORKDIR}/{model}/{args.digest}.svg'):
      os.unlink(f'{WORKDIR}/{model}/{args.digest}.svg')
      print(f'{args.digest} deleted ok') # success
    else: raise FileNotFoundError(f'SVG not deleted {model}/{args.digest}')
  else: raise ValueError(f'nothing named {args.digest} in database')

elif (args.keyword == 'explode'):
  ''' assumptions: gridsize is A3 (297 x 420 mm) 
      image is square: with margins grid is 270 x 270
      numbers of cells defined by cell length which is always divisible by 3
      to ensure whole numbers: clen must be one of: 9 18 27 45 54 90
  '''
  print(f'{args.model=} {args.size=} {args.line=}')
  print('-'*80)
  svglin     = SvgLinear(args.size)
  celldata   = tf.readConf(args.model)
  ver        = fnam.index(tf.VERSION) + 1
  if args.model == 'minkscape': # default model
    positions = config.positions
    penam     = config.penam[2]  # pen names for htmstart pal
    block     = Make(args.size, pen_names=penam)
  else:                         # TODO source positions from model
    bd        = BlockData(args.model)
    positions = bd.readPositions(args.model)
    penam     = bd.penNames(ver)
    block     = Make(args.size, pen_names=penam)

  block.walk(positions, celldata)
  if args.line: 
    block.meander(padding=False)
  block.hydrateGrid(line=args.line)
  svglin.explode(block)
  svglin.render(args.model, line=args.line)

elif (args.keyword == 'init'):
  ''' pull a palette from db and write to tmpfile
      generate an editable config file 
  '''
  print(f'{args.model=} {args.palette=} {args.inkpal=}')
  if args.inkpal: # e.g. uniball.gpl
    paldir  = '/home/gavin/.config/inkscape/palettes/'
    palette = pmk.inkscapePal(paldir, f"{args.inkpal}.gpl")
    tf.exportPalfile(args.inkpal, palette) 
    print(f"{args.inkpal}.txt was written")
  elif args.palette in range(99) and args.model:
    _model, src, celldata = view.generate(model=args.model, ver=args.palette)
    tf.conf(args.model, fnam[args.palette]) # conf state is a symlink
    celldata = tf.convertToList(celldata) # become a list before writing
    tf.write(args.model, celldata)
    print(f"""
initialising {args.model} with {len(celldata)} cells from {src}
palette {fnam[args.palette]}""")
  elif args.palette in range(99): # export from palette table
    fn    = fnam[args.palette]
    pal.loadPalette(ver=args.palette)
    #pp.pprint(pal.palette)
    palette = pal.palette # keep order so relations are grouped
    tf.exportPalfile(fn, palette) 
    print(f"{fn}.txt was written")
  else:
    ''' randomly generate conf/MODEL.yaml and palette
    '''
    ver                  = tf.setVersion(ver=args.palette)
    model, src, celldata = view.generate(model=args.model, ver=ver)
    tf.write(model, celldata)
    print(f"""
initialising {model} with {len(celldata)} cells from {src}
palette {fnam[ver]}""")

elif (args.keyword == 'ls'):
  ''' list from db or config
  '''
  print(f'{args.output=}')
  if args.output == 'pal': 
    [print(f"{i}\t{name}") for i, name in enumerate(fnam)]
  else: print(modl.stats())

elif (args.keyword == 'publish'):
  ''' used by reith to update pubdate
  '''
  print(f'{args.digest=}')
  view.update(d)
  print(f"updated ok")

elif (args.keyword == 'read'):
  print(f'{args.model=} {args.digest=}')
  if args.model:
    bd        = BlockData(args.model)
    blocksize = modl.read(model=args.model)[2]
    print(bd.prettyPrint(args.model, blocksize[0], blocksize[1]))
  else:  # reith is consumer
    view = view.readMeta(digest=args.digest)
    print(' '.join(view[:2]))

elif (args.keyword == 'build'):
  ''' generate an SVG from tmpfile using ElementTree
  '''
  print(f'{args.model=} {args.size=} {args.palette=} {args.digest=} {args.line=}')
  if args.palette is not None or args.digest: # universal has index 0 :-/
    fn      = fnam[args.palette] if args.palette >=0 else args.digest
    palette = tf.importPalfile(fn)
    svgpal.render(fn, palette)
    print(f"palettes/{fn}.html was written")
  elif args.model and args.size:
    block     = Make(args.size)
    '''
      celldata  = config.cells
    '''
    if args.model == 'minkscape': # default model
      positions = config.positions
    else: # TODO get positions from tf.positions() after readConf
      bd        = BlockData(args.model)
      positions = bd.readPositions(args.model)
    
    celldata  = tf.readConf(args.model)
    ver       = fnam.index(tf.VERSION)
    view.validate(celldata, ver=ver)

    if args.line:
      block.walk(positions, celldata)
      block.meander(padding=False)
      svg.drawLine(block, svgfile=f'_.{args.model}._.line')
    else:
      block.walk(positions, celldata)
      svg.draw(block, svgfile=f'_.{args.model}._.box')
    print(f'tmp/{args.model}.svg was built')
  else:
    raise Warning(f'missing {args.model=}, {args.palette=} or {args.digest=}')

'''
the
end
'''
