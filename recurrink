#!/usr/bin/env python3
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
import os
import argparse
import time
import random
import pprint
from model import ModelData, SvgModel, SvgPalette, SvgWriter
from block import PaletteMaker, TmpFile, Views, BlockData, Make
from cell import Palette
from config import *
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
modl    = ModelData()
pal     = Palette()
pmk     = PaletteMaker()
svgpal  = SvgPalette()
tf      = TmpFile()
view    = Views()
WORKDIR = config.directory['rinks']
PUBDIR  = config.directory['pubq']
PALDIR  = config.directory['palettes']
fnam    = pal.friendlyPenNames()
pp      = pprint.PrettyPrinter(indent=2)
start_t = time.time()
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
''' get inputs from command line
'''
parser = argparse.ArgumentParser(prog='recurrink')
subparsers = parser.add_subparsers(dest='keyword', help='sub-command help')

parser_b = subparsers.add_parser('build', help='build svg from config')
parser_b.add_argument(
  '-p', '--palette', type=int, choices=range(0, 99), metavar='[0-99]',
  help='palette version to write as html' 
)
parser_b.add_argument('-d', '--digest', help='palette from rink to write as svg')
parser_b.add_argument('-m', '--model', help='name of model to build')
parser_b.add_argument(
  "-s", "--size", help='cell lengths: 18 36 54 90', nargs='?', 
  type=int, const=54
)
parser_b.add_argument(
  '-l', '--line',  help='stroke width *0.7 or omit to paint',
  action=argparse.BooleanOptionalAction
)
parser_b.add_argument(
  '-z', '--layer',  metavar='2-3', help='numof layers *3 or 2', 
  nargs='?', const=3, type=int
)

parser_m = subparsers.add_parser(
  'compare', help='compare palettes: tmpfile to db'
)
parser_m.add_argument(
  "-p", "--palette", help='read palette from version in db', type=int, 
  choices=range(0, 99), metavar='[0-99]', required=True
)
parser_m.add_argument(
  '-d', '--digest', help='read palette from rink in tmpfile', required=True
)

parser_c = subparsers.add_parser('commit', help='write immutable entry to db')
parser_c.add_argument( 
  "-a", "--author", choices=['human', 'machine'], nargs='?', const='human'
)
parser_c.add_argument("-m", "--model", help="name of model to commit") 
parser_c.add_argument(
  "-s", "--size", help='cell lengths: 18 36 54 90', nargs='?', 
  type=int, required=True
)
parser_c.add_argument(
  "-p", "--palette", help='new palette to create', type=int, 
  choices=range(0, 99), metavar='[0-99]' #, required=True
)
parser_c.add_argument('-d', '--digest', help='swap rink to use palette')
parser_c.add_argument("-i", "--inkpal", help='Insert GPLFILE to pens table')

parser_k = subparsers.add_parser('clone', help='get copy of config')
parser_k.add_argument('-d', '--digest', help='rink to clone', required=True)
parser_k.add_argument(
  '-o', '--output', nargs='?', choices=['cell','pal'], const='cell',
  help='clone celldata by default, else palette data'
)

parser_d = subparsers.add_parser('delete')
parser_d.add_argument(
  '-d', '--digest', help='rink to remove from db', required=True
)

parser_e = subparsers.add_parser(
  'explode', help='stamp a block across the grid'
)
parser_e.add_argument(
  "-s", "--size", help='cell lengths: 18 36 54 90', type=int, required=True
)
parser_e.add_argument(
  '-l', '--line',  help='output for plotter', 
  action=argparse.BooleanOptionalAction
)
parser_e.add_argument(
  '-m', '--model', help='model to be exploded', 
  nargs='?', const='minkscape', required=True
)
parser_e.add_argument(
  '-z', '--layer',  help='numof layers *3 or 2', nargs='?', const=3, type=int
)

parser_i = subparsers.add_parser('init', help='set config to create new image')
parser_i.add_argument('-m', '--model', help='randomly generate conf for model')
parser_i.add_argument(
  "-p", "--palette", type=int, choices=range(0, 99), metavar='[0-99]',
  help='palette version to initialise'
)
parser_i.add_argument("-i", "--inkpal", help='GPL source to generate palette')

parser_l = subparsers.add_parser('ls', help='list models or palettes')
parser_l.add_argument(
  "-o", "--output", choices=['model','pal'], const='model', nargs='?', 
  help='model by default'
)

parser_p = subparsers.add_parser('publish', help='add release date to db')
parser_p.add_argument(
  '-d', '--digest', help='rink to mark as released', required=True
)

parser_r = subparsers.add_parser('read', help='get rink metadata')
parser_r.add_argument('-m', '--model', help='name of base model')
parser_r.add_argument('-d', '--digest', help='hex name with 32 char')
args    = parser.parse_args()
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
if (args.keyword == 'compare'):
  ''' compare palettes given ver and digest
      expect tmp/PALETTE.txt tmp/DIGEST.txt to exist already
  '''
  print(pmk.cmpPalettes(fnam[args.palette], args.digest))

elif (args.keyword == 'commit'):
  ''' read config, write to database and return digest
      clean file system except for tmp/model.txt

    When both pal and digest are given remember to do this first
      export view using recurrink init -v --> /tmp/MODEL.txt
      export pal from using palette init -p

    When only pal then
      convert palette in tmpfile to sql INSERT but first manually 
      create tmpfile NEW_PAL.txt 
      add NEW_PAL to friendly_name
      use the index of config.friendly_name[] as arg
  '''
  if args.palette and args.digest:
    model      = view.read_meta(args.digest)[0]
    celldata   = tf.read(model, output=list())
    numupdated = pal.swap_palette(celldata, ver, digest)
    print(f"""
update {numupdated} view 
swapping {args.digest} to palette {fnam[args.palette]}""")
  elif args.palette:
    palette         = tf.importPalfile(fnam[args.palette])
    missing_colours = pmk.colour_check(pal, palette)
    if len(missing_colours): # add any new colours 
      pal.create_colours(missing_colours)
      print(f"{len(missing_colours)} new colours ")
    pal.read_palette(args.palette)
    new_pal = pmk.makeUnique(args.palette, pal, palette)
    print(f"{len(new_pal)} new entries")
  elif args.inkpal:
    gpldata = pmk.readInkscapePal(PALDIR, f'{args.inkpal}.gpl')
    pal.penNames(args.inkpal, gpldata)

  elif args.author and args.model:
    celldata = tf.readConf(args.model)
    metadata = tf.readConf(args.model, meta=True)
    pal      = metadata['palette']
    ver      = fnam.index(pal)
    size     = args.size / 10  # make it fit scale type in db
    lc       = -1  # TODO colournum should have a real value
    tf.setDigest(celldata=celldata)
    #print(f''' {tf.digest} {len(celldata.keys())} {args.model=} {args.author=} {ver=}, {size=} colournum {lc}''')
    if os.path.isdir(f"{WORKDIR}/{args.model}"):
      if view.create(
        tf.digest, celldata, model=args.model, author=args.author, 
        ver=ver, scale=size, colournum=lc
      ):
        if os.path.isfile(f"tmp/{args.model}.svg"):
          svgname = f"{WORKDIR}/{args.model}/{tf.digest}.svg"
          os.rename(f"tmp/{args.model}.svg", svgname)
          os.symlink(f"{svgname}", f"{PUBDIR}/{tf.digest}.svg")
          response = svgname
        else:
          raise FileNotFoundError(f"{args.model}.svg not found in tmp")
      else:
        response = 'unknown error'
    else:
      raise FileNotFoundError(f"{args.model} not found in {WORKDIR}")
    print(response)
  else: print("cannot commit: missing model, author or palette")

elif (args.keyword == 'clone'):
  ''' pull from db to create tmp/MODEL.txt from digest
  '''
  model, author, scale, ver = view.readMeta(digest=args.digest)
  if args.output == 'pal': # export view as palette
    palette = set(pal.read_view(args.digest))
    tf.exportPalfile(args.digest, palette) 
    print(f"palettes/{args.digest}.txt was written")
  else:   # assume we want celldata
    celldata  = view.read(digest=args.digest) #, output=list())
    #tf.conf(model, fnam[ver]) # conf state is a symlink
    tf.setVersion(ver)
    tf.write(model, celldata)
    print(f"""
cloning {model}
with {len(celldata)} cells
palette {fnam[ver]}""")

elif (args.keyword == 'delete'): 
  # as delete has no help text it is not listed by argparse
  print(f'{args.digest=}')
  ''' both svg and view must exist for the delete to succeed
      4e3e83e969f2b41bf47fda2ec430a8f8 
  '''
  viewdata = view.readMeta(args.digest)
  if len(viewdata):
    view.delete(args.digest) 
    model = viewdata[0]
    if os.path.isfile(f'{PUBDIR}/{args.digest}.svg'):
      os.unlink(f'{PUBDIR}/{args.digest}.svg')
    if os.path.isfile(f'{WORKDIR}/{model}/{args.digest}.svg'):
      os.unlink(f'{WORKDIR}/{model}/{args.digest}.svg')
      print(f'{args.digest} deleted ok') # success
    else: raise FileNotFoundError(f'SVG not deleted {model}/{args.digest}')
  else: raise ValueError(f'nothing named {args.digest} in database')

elif (args.keyword == 'explode'):
  ''' assumptions: gridsize is A3 (297 x 420 mm) 
      image is square: with margins grid is 270 x 270
      numbers of cells defined by cell length which is always divisible by 3
      to ensure whole numbers: clen should be: 9 18 27 36 45 54 90 ..
  '''
  svglin     = SvgModel(args.size)
  celldata   = tf.readConf(args.model)
  ver        = fnam.index(tf.VERSION)
  if args.model == 'minkscape': # default model
    positions = config.positions
    penam     = config.penam[2]  # pen names for htmstart pal
    block     = Make(args.size, linear=bool(args.line), pen_names=penam)
  else:                         # TODO source positions from model
    bd        = BlockData(args.model)
    positions = bd.readPositions(args.model)
    penam     = bd.penNames(ver)
    block     = Make(args.size, linear=bool(args.line), pen_names=penam)

  block.walk(positions, celldata, z=args.layer)
  block.hydrateGrid()
  svglin.explode(block)
  svglin.render(args.model, line=bool(args.line))
  print(f'tmp/{args.model}.svg was exploded')

elif (args.keyword == 'init'):
  ''' pull a palette from db and write to tmpfile
      generate an editable config file 
  '''
  if args.inkpal: # e.g. uniball.gpl
    palette = pmk.inkscapePal(PALDIR, f"{args.inkpal}.gpl")
    tf.exportPalfile(args.inkpal, palette) 
    print(f"palettes/{args.inkpal}.txt was written")
  elif args.palette in range(99) and args.model:
    _model, src, celldata = view.generate(model=args.model, ver=args.palette)
    tf.conf(args.model, fnam[args.palette]) # conf state is a symlink
    celldata = tf.convertToList(celldata) # become a list before writing
    tf.write(args.model, celldata)
    print(f"""
initialising {args.model} with {len(celldata)} cells from {src}
palette {fnam[args.palette]}""")
  elif args.palette in range(99): # export from palette table
    fn    = fnam[args.palette]
    pal.loadPalette(ver=args.palette)
    #pp.pprint(pal.palette)
    palette = pal.palette # keep order so relations are grouped
    tf.exportPalfile(fn, palette) 
    print(f"{fn}.txt was written")
  else:
    ''' randomly generate conf/MODEL.yaml and palette
    '''
    ver                  = tf.setVersion(ver=args.palette)
    model, src, celldata = view.generate(model=args.model, ver=ver)
    tf.write(model, celldata)
    print(f"""
initialising {model} with {len(celldata)} cells from {src}
palette {fnam[ver]}""")

elif (args.keyword == 'ls'):
  ''' list from db or config
  '''
  if args.output == 'pal': 
    [print(f"{i}\t{name}") for i, name in enumerate(fnam)]
  else: print(modl.stats())

elif (args.keyword == 'publish'):
  ''' used by reith to update pubdate
  '''
  view.update(d)
  print(f"updated ok")

elif (args.keyword == 'read'):
  if args.model:
    bd        = BlockData(args.model)
    blocksize = modl.read(model=args.model)[2]
    print(bd.prettyPrint(args.model, blocksize[0], blocksize[1]))
  else:  # reith is consumer
    view = view.readMeta(digest=args.digest)
    print(' '.join(view[:2]))

elif (args.keyword == 'build'):
  ''' generate an SVG from tmpfile or an HTML palette
  '''
  # TODO somefink smells funky
  if args.palette:
    fn      = fnam[args.palette]
    palette = tf.importPalfile(fn)
    svgpal.render(fn, palette)
    print(f"palettes/{fn}.html was written")
  elif args.digest:
    fn      = args.digest
    palette = tf.importPalfile(fn)
    svgpal.render(fn, palette)
    print(f"palettes/{fn}.html was written")
  elif args.model and args.size:
    block     = Make(args.size, linear=bool(args.line))
    svglin    = SvgModel(args.size)

    if args.model == 'minkscape': # default model
      positions = config.positions
    else: # TODO get positions from tf.positions() after readConf
      bd        = BlockData(args.model)
      positions = bd.readPositions(args.model)
    
    celldata  = tf.readConf(args.model)
    ver       = fnam.index(tf.VERSION)
    view.validate(celldata, ver=ver)
    block.walk(positions, celldata, z=args.layer)

    svgfile   = args.model
    svgfile  += '_line' if bool(args.line) else '_box'
    block.hydrateGrid()
    svglin.build(block)
    svglin.render(svgfile, line=bool(args.line))
    print(f'tmp/{svgfile}.svg was built')
  else:
    raise Warning(f'''missing argument
{args.model=}, {args.size}, {args.palette=} or {args.digest=}''')

print(f"--- {round(time.time() - start_t, 3)} seconds ---")
'''
the
end
'''
