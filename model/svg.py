import pprint
import xml.etree.ElementTree as ET
from model import Layout
pp = pprint.PrettyPrinter(indent = 2)

class Svg(Layout):
  def __init__(self, scale=1, unit='px', gridsize=0, cellsize=0, inkscape=False):
    ''' svg:transform(scale) is better than homemade scaling
        but is lost when converting to raster. Instagram !!!
    '''
    super().__init__(unit, scale, gridsize, cellsize)
    ET.register_namespace('',"http://www.w3.org/2000/svg")
    root = ET.fromstring(f'''
    <svg 
      xmlns="http://www.w3.org/2000/svg" 
      viewBox="0 0 {self.gridsize} {self.gridsize}" 
      width="{self.gridsize}{self.unit}" height="{self.gridsize}{self.unit}"
      transform="scale(1)"></svg>
    ''')
    comment = ET.Comment(
      f' scale:{scale} cellsize:{cellsize} gridsize:{gridsize} '
    )
    root.insert(0, comment)  # 0 is the index where comment is inserted
    if inkscape:             # add tags so plotter can split on layer
      ET.register_namespace(
        'inkscape',"http://www.inkscape.org/namespaces/inkscape"
      )
      root.set('xmlns:inkscape', "http://www.inkscape.org/namespaces/inkscape")
      self.ns1 = '{http://www.inkscape.org/namespaces/inkscape}'
    #ET.dump(root)
    self.ns = '{http://www.w3.org/2000/svg}'
    self.root = root
    self.inkscape = inkscape

  def make(self, doc):
    ''' expand the doc from gridwalk and convert to XML
    '''
    #pp.pprint(self.doc)
    uniqid = 0 # xml elements must have unique IDs
    for group in doc:
      uniqid += 1
      g = ET.SubElement(self.root, f"{self.ns}g", id=str(uniqid))
      g.set('style', group['style'])
      if self.inkscape:
        g.set('inkscape:groupmode', "layer") # need namespace for inkscape
        g.set('inkscape:label', self.trimStyle(group['style'])) # e.g "CCC"
      for s in group['shapes']:
        uniqid += 1
        name = s['name']
        #print(f"{name=} {str(uniqid)} {s.keys()=}")
        if name == 'circle':
          circle = ET.SubElement(g, f"{self.ns}circle", id=str(uniqid))
          circle.set('cx', f"{s['cx']:g}")
          circle.set('cy', f"{s['cy']:g}")
          circle.set('r', f"{s['r']:g}")
        #elif name == 'rect':
        elif name == 'square' or name == 'line':
          rect = ET.SubElement(g, f"{self.ns}rect", id=str(uniqid))
          rect.set("x", f"{s['x']:g}")
          rect.set("y", f"{s['y']:g}")
          rect.set("width", f"{s['width']:g}")
          rect.set("height", f"{s['height']:g}")
        #elif name == 'polygon':
        elif name == 'triangl' or name == 'diamond' or name == 'parabola':
          polyg = ET.SubElement(g, f"{self.ns}polygon", id=str(uniqid))
          polyg.set("points", s['points'])
        elif name == 'void':
          pass
        else:
          # pp.pprint(s)
          t = ET.SubElement(g, f"{self.ns}text", id=str(uniqid))
          t.text = name
          tx = s['x'] + 10
          ty = s['y'] + 30
          t.set("x", str(tx))
          t.set("y", str(ty))
          t.set("class", "{fill:#000;fill-opacity:1.0}")


  def write(self, svgfile):
    tree = ET.ElementTree(self.root)
    ET.indent(tree, level=0)
    tree.write(svgfile)

class LinearSvg(Svg):
  ''' output design to a two dimensional SVG that a plotter can understand
  '''
  def __init__(self, scale=1.0, gridsize=None, cellsize=None):
    super().__init__(unit='mm', scale=scale, gridsize=gridsize, cellsize=cellsize)
    self.labels = list()

  def wireframe(self, blockOne, writeconf=False):
    ''' preview shapes generated by Flatten OR write meander.conf
    '''
    msg = self.writeMeanderConf(blockOne) if writeconf else self.markup(blockOne)
    return msg

  def markup(self, done):
    inner_p = list()
    uniqid = 1 # xml elements must have unique IDs
    g      = ET.SubElement(self.root, f"{self.ns}g", id=str(uniqid))
    g.set('style', 'fill:#FFF;stroke:#000;stroke-width:1')
    for i in done:
      gmk = done[i]
      uniqid += 1
      ''' SVG polygon
      '''
      p      = ET.SubElement(g, f"{self.ns}polygon", id=str(uniqid))
      points = str()
      # print(f"{shape_name=}")
      if gmk.label[0] == 'S':  # Square Ring is a multi part geometry
        outer  = list(gmk.shape.exterior.coords)
        inner  = list(gmk.shape.interiors)
        coords = outer 
        [inner_p.append(list(lring.coords)) for lring in inner]
      else:
        coords = list(gmk.shape.boundary.coords)
      for c in coords:
        coord = ','.join(map(str, c))
        points += f"{coord} "
      p.set("points", points.strip())

    uniqid += 1
    g2 = ET.SubElement(self.root, f"{self.ns}g", id=str(uniqid))
    g2.set('style', 'fill:#FFF;stroke:#000;stroke-width:1;stroke-dasharray:0.5')
    for coords in inner_p:  
      uniqid += 1
      ''' Add any points from inner ring
      '''
      p      = ET.SubElement(g2, f"{self.ns}polygon", id=str(uniqid))
      points = str()
      for c in coords:
        coord = ','.join(map(str, c))
        points += f"{coord} "
      p.set("points", points.strip())


  def cflatWireframe(self, block1):
    ''' preview shapes generated by CellMaker.flatten
    '''
    max_blocksize = 3 * 15 # e.g. minkscape (3,1) with cellsize 15
    super().__init__(unit='mm', scale=2, gridsize=max_blocksize, cellsize=15)

    inner_p = list()
    uniqid = 1 # xml elements must have unique IDs
    g      = ET.SubElement(self.root, f"{self.ns}g", id=str(uniqid))
    g.set('style', 'fill:#FFF;stroke:#000;stroke-width:1;fill-opacity:0.5')
    for pos, cell in block1.items():
      for layer in cell.bft:
        shape = layer.this
        if shape.name in ['invisible', 'void', 'multipolygon']:
          continue       # multi part geometry not expected here!
        uniqid += 1
        ''' SVG polygon
        '''
        p = ET.SubElement(g, f"{self.ns}polygon", id=str(uniqid))
        comment = ET.Comment( f' {layer.label} {shape.name}')
        points = str()
        if shape.name == 'sqring': # multi part geometry
          outer  = list(shape.data.exterior.coords)
          inner  = list(shape.data.interiors)
          coords = outer 
          [inner_p.append(list(lring.coords)) for lring in inner]
        else:
          coords = list(shape.data.boundary.coords)
        for c in coords:
          coord = ','.join(map(str, c))
          points += f"{coord} "
        p.set("points", points.strip())
        p.insert(0, comment)  # 0 is the index where comment is inserted

    uniqid += 1
    g2 = ET.SubElement(self.root, f"{self.ns}g", id=str(uniqid))
    g2.set('style', 'fill:#FFF;stroke:#000;stroke-width:1;stroke-dasharray:0.5')
    for coords in inner_p:  
      uniqid += 1
      ''' Add any points from inner ring
      '''
      p = ET.SubElement(g2, f"{self.ns}polygon", id=str(uniqid))
      points = str()
      for c in coords:
        coord = ','.join(map(str, c))
        points += f"{coord} "
      p.set("points", points.strip())

  def writeMeanderConf(self, done):
    ''' print to console an initial meander
    '''
    out = "meander:\n"
    for i in done:
      gmk = done[i]
      tx = gmk.shape.bounds[0]
      ty = gmk.shape.bounds[1]
      out += f"  {gmk.label}: N # {int(tx):>3},{int(ty):>3}\n"
    return out

  def make(self, model, blocks, meander_conf=dict()):
    self.doc = dict()     # reset for regrouping by fill
    for block in blocks:
      self.regroupColors(block, meander_conf=meander_conf)
      print('.', end='', flush=True)
    self.svgGroup()
    return f'tmp/{model}_mm.svg'

  def regroupColors(self, done, meander_conf):
    for i in done:
      gmk = done[i]
      xy  = gmk.meander.fill(conf=meander_conf, label=gmk.label)
      if xy.is_empty: # meander could not fill d
        continue
      if gmk.pencolor in self.doc:
        self.doc[gmk.pencolor].append(xy)
      else:
        self.doc[gmk.pencolor] = list()
        self.doc[gmk.pencolor].append(xy)

  def svgMarkup(self, doc):
    uniqid = 0
    for content in doc:
      uniqid += 1
      g = ET.SubElement(self.root, f"{self.ns}g", id=str(uniqid))
      g.set('style', content['style']) # swap fill for stroke
      for shape in content['shapes']:
        if shape['name'] == 'void': continue # empty group
        elif 'points' in shape: 
          uniqid += 1
          polyln = ET.SubElement(g, f"{self.ns}polyline", id=str(uniqid))
          polyln.set("points", shape['points'])
        else: print(f"hello new {shape['name']}")

  def svgGroup(self):
    ''' when pencolor is white it will not plot well on white paper
    but it is still allowed here

    plotters cannot fill, so style fill:none
    but they can draw lines, so polyline not polygon
    '''
    uniqid = 0
    for pencolor in self.doc:
      uniqid += 1
      g = ET.SubElement(self.root, f"{self.ns}g", id=str(uniqid))
      g.set('style', f"fill:none;stroke:#{pencolor}")

      for line in self.doc[pencolor]:
        uniqid += 1
        points = str()
        for c in list(line.coords):
          x = c[0]
          y = c[1]
          points += f"{x},{y} "
        polyln = ET.SubElement(g, f"{self.ns}polyline", id=str(uniqid))
        polyln.set("style", 'stroke-width:0.5') # to show 1mm stripes in gthumb
        polyln.set("points", points)

'''
the
end
'''
