#!/usr/bin/env python
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
''' HOW TO swap pals and migrate

palswap clone -d RINKID -o
palswap build -m MODEL -o
# check tmp/MODEL_db1.svg
palswap clone -d RINKID -opal -p PEN
palswap build -m MODEL -opal
# compare tmp/waltz_pal.svg and if new pal ok
palswap commit -m MODEL -x -o
# and then copy to db2
palswap commit -m MODEL -x -odb2
palswap clone -d RINKID -odb2
palswap build -m MODEL -odb2
# compare tmp/waltz_db2.svg to check for db migration errors
'''

import sys
import argparse
import pprint
from model import ModelData, SvgModel
from model.data2 import ModelData2
from model.init  import Init
from block import PaletteMaker, TmpFile, Views, BlockData, Make
from block.data import Compass
from block.data2 import BlockData2
# from block.tmpfile2 import TmpFile2
from cell import Palette, Strokes
from cell.data2 import CellData2, Transform
from config import *



''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
pal     = Palette()
pmk     = PaletteMaker()
tf      = TmpFile()
view    = Views()
md2     = ModelData2()
bd2     = BlockData2()
cd2     = CellData2()
# tf2     = TmpFile2()
fnam    = pal.friendlyPenNames()
pp      = pprint.PrettyPrinter(indent=2)
view  = Views()
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
''' get inputs from command line
    see block/README.md Palette conversion
'''
def main(args):
  parser     = argparse.ArgumentParser(prog='palswap')
  subparsers = parser.add_subparsers(dest='keyword', help='sub-command help')
  parser_b   = subparsers.add_parser('build',  help='build svg from config')
  parser_k   = subparsers.add_parser('clone',  help='get copy of config')
  parser_c   = subparsers.add_parser('commit', help='write to db')
  parser_i   = subparsers.add_parser('init', help='generate config')

  arg_d = { 'help': 'rinkid to write as yam l', 'required': True }
  arg_i = { 'help': 'name of model to use as input', 'required': False }
  arg_m = { 'help': 'name of model to use as input', 'required': True }
  arg_o = {
    'help'   : 'output refers to db1 by default',
    'nargs'  : '?', 
    'choices': ['db1','pal', 'db2'], 
    'const'  : 'db1'
  }
  arg_p = { 'help': 'name of pen e.g. uniball' }
  arg_v = {
    'help'    : 'pen version',
    'type'    : int, 
    'choices' : range(1, 99), 
    'metavar' : '[1-99]'
  }
  arg_x = {
    'help'   :'exchange colours from db1 or conf to out',
    'action' : argparse.BooleanOptionalAction
  }
  # to come back to later # to come back to later # to come back to later 
  arg_z = {
    'help'   : 'numof layers *3 or 2', 
    'metavar': '2-3', 
    'nargs'  : '?', 
    'const'  : 3, 
    'type'   : int
  }

  parser_k.add_argument('-p', '--penam',    **arg_p)
  parser_k.add_argument('-d', '--digest',   **arg_d)
  parser_k.add_argument('-o', '--output',   **arg_o)
  parser_b.add_argument('-m', '--model',    **arg_m)
  # parser_b.add_argument('-z', '--layer',    **arg_z)
  parser_b.add_argument('-o', '--output',   **arg_o)
  parser_c.add_argument('-m', '--model',    **arg_m)
  parser_c.add_argument('-o', '--output',   **arg_o)
  parser_c.add_argument('-x', '--exchange', **arg_x)
  parser_i.add_argument('-m', '--model',    **arg_i)
  parser_i.add_argument('-p', '--penam',    **arg_p)
  return parser.parse_args()

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
def init(args):
  #print(args.model, args.penam)
  init       = Init()
  model, pen = init.setInput(args.model, args.penam)
  src, data  = init.generate(model, pen)
  newver     = init.ver + 7
  tf.setVersion(newver)
  tf.write(model, None, data)
  print(f'''generated {model} with {len(data.keys())} cells
using {pen} from source: {src} 
''')

def clone(args):
  if args.digest:
    (model, 
    author, 
     scale, 
       ver,
   created, 
   pubdate) = view.readMeta(digest=args.digest)
  if args.output == 'db2': 
    cloneDb2(args.digest, model, ver)  # from new db
  elif args.output == 'db1': 
    cloneDb1(args.digest, model, ver)  # db1
    buildOut(model, args.output)
  elif args.output == 'pal': 
    clonePal(args.digest, args.penam)  # swap colours
    buildOut(model, args.output)
  else: 
    print('check input -o without a value = db1')

def cloneDb1(rinkid, model, ver):  # assume we want celldata from db1
  ''' pull from db1 to create tmp/MODEL.yaml
  '''
  celldata  = view.read(digest=rinkid) #, output=list())
  tf.setVersion(ver)
  tf.write(model, rinkid, celldata)
  print(f"""
cloning {model} {rinkid} from db1
with {len(celldata)} cells
using {fnam[ver]} pens""")

def cloneDb2(rinkid, model, ver):
  ''' pull from db2 to create tmp/MODEL.yaml
  '''
  _, mid          = md2.model(name=model)
  new_ver         = bd2.version(ver)
  print(f'{mid=} {new_ver=}')
  _, rinkdata     = bd2.rinks(rinkid)
  model, metadata = tf.rinkMeta(rinkdata)
  celldata        = tf.cellData(rinkdata)
  tf.writePretty(model, metadata, celldata)
  print(f"""
cloning {model} {rinkid} from db2
with {len(celldata)} cells
using {fnam[ver]} pens""")

def clonePal(rinkid, pen):
  ''' write a conf using the new pal
  '''
  meta     = view.readMeta(rinkid) #Â model auth scale ver
  model    = meta[0]
  bd       = BlockData(model)
  pens     = md2.pens()
  ver      = pens.index(pen) + 7
  print(f'''old ver {meta[3]} new {pen=} {ver=} 
{rinkid=} {model}
''')
  swp      = swapOldnew(ver, rinkid)
  celldata = view.read(digest=rinkid)
  position = bd.readPositions(model)
  celldata = pmk.updateCells(celldata, swp) # transform celldata
  tf.write(model, rinkid, celldata)         # write new colors to palswap.yaml

def swapOldnew(ver, rinkid):
  ''' do the swap right here
  '''
  pal     = Palette(ver)
  palette = set(pal.read_view(rinkid))
  tf.exportPalfile(rinkid, palette) 
  print(f"palettes/{rinkid}.txt was written for penver: {ver}")

  tf.setVersion(ver=ver)
  pal.loadPalette()     # merge fg bg stroke into uniqfill 
  oc      = tf.getOldColors(rinkid)
  nc      = pmk.setLookUp(pal.uniqfill) # for search the new colour
  print(f'''{len(oc)} to swap
{len(nc)} to search
''')
  swp      = pmk.swapColors(oc, nc)
  uniqnew  = set(list(swp.values()))
  print(f'found {len(uniqnew)} new colours')
  #pp.pprint(swp)
  return swp

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
def commit(args):
  if args.output is None:
    print('check input e.g. -o writes to db1 by default')
  elif args.exchange and args.output == 'db1': commitDb1(args.model)
  elif args.exchange and args.output == 'db2': commitDb2(args.model)
  elif args.output: commitNew(args)
  else            : print(f'cannot commit {args.model}')

def commitDb1(model):
  ''' read yaml and update db1 with new pal
      
      example inputs: ver 9 is copicsketch. only 8..12 can work
      rinkid '180f1989f54ff03291ec31e164f2a79f'
  '''
  metadata  = tf.readConf(model, meta=True)
  rinkid    = metadata['id']
  ver       = fnam.index(tf.VERSION)
  celldata  = view.read(digest=rinkid) # to be updated

  stk      = Strokes(ver)
  pal      = Palette(ver=ver) 
  swp      = swapOldnew(ver, rinkid) # same as MODEL_db1.svg with clone -opal
  pids     = pal.updatePids(ver, swp, celldata)
  rownum   = pal.swapPalette(pids, ver, rinkid)
  sids     = stk.updateSids(swp, celldata) # {'a': 309, 'b': 310, ..
  # pp.pprint(sids)
  rownum  += stk.swapSid(sids, ver, rinkid)
  print(f'''{ver=} {model}
{rownum} rows updated db1
''')

def commitDb2(model):
  ''' after pal swap
      copy rink from db1 to db2
  '''
  metadata  = tf.readConf(model, meta=True)
  rinkid    = metadata['id']
  rinkmeta  = view.readMeta(rinkid)
  bd        = BlockData(rinkmeta[0])
  blocks    = bd.readPositions(rinkmeta[0]) 
  tx        = Transform()

  # Model
  nrc, mid  = md2.model(name=rinkmeta[0])
  print(f'{model} {rinkid}')
  print(f'model {nrc} new records') if nrc else print(
    f'{rinkmeta[0]} {mid=} found'
  )
  nrc, blocks  = md2.blocks(mid, blocks)
  print(f'blok {nrc} new records') if nrc else print(f'{len(blocks)=} found')
  compass      = Compass(rinkmeta[0])
  nrc, compass = md2.compass(mid, compass.conf)
  if nrc:       print(f'comp {nrc} new records') 
  elif compass: print(f'{len(compass)=} found')
  else:         print('no compass')
  
  # Block
  ver           = bd2.version(rinkmeta[3])
  print(f'{ver=} is new converted from old ver {rinkmeta[3]}') 
  pal           = Palette(ver=ver) 
  pens          = pal.penNames(None, dict(), ver=rinkmeta[3])
  nrc, colors   = bd2.colors(ver, colors=pens)
  print(f'colors {nrc} new records') if nrc else print(f'{len(colors)=} found')
  nrc, rinkdata = bd2.rinks(rinkid, mid, ver, rinkmeta[4:])
  print(f'rink {nrc} new records') if nrc else print(f'{len(rinkdata)=} found')
  celldata      = view.read(digest=rinkid) 
  celldata      = tx.dataV1(celldata)
  
  # Cell
  nrc, geom = cd2.geometry(rinkid, celldata)
  print(f'geom {nrc} new records') if nrc else print(f'{len(geom)=} found')
  nrc, stk = cd2.strokes(rinkid, rinkdata[2], celldata)
  print(f' stk {nrc} new records') if nrc else print(f'{len(stk)=} found')
  nrc, pal = cd2.palette(rinkid, rinkdata[2], celldata)
  print(f' pal {nrc} new records') if nrc else print(f'{len(pal)=} found')

def commitNew(args):
  if args.output == 'db1':
    print('wont do')
    return
  metadata = tf.readConf(args.model, meta=True)
  rinkid   = metadata['id']
  palette  = metadata['palette']
  if rinkid:
    print(f"{rinkid} not expected here")
    return

  tx        = Transform()
  celldata  = tf.readConf(args.model)
  rinkid    = tf.setDigest(celldata)
  _, mid    = md2.model(name=args.model)
  pens      = md2.pens()
  ver       = pens.index(palette)
  s         = 18 # TODO args.size
  f         = 1  # args.factor
  d         = [None, None] # pubdate and created not relevant here
  print(' '.join(list(celldata.keys())))
  # print(rinkid, mid, ver, s, f)
  nrc, rinkdata = bd2.rinks(rinkid, mid, ver, dates=d, size=s, factor=f)
  print(f'rink {nrc} new records') if nrc else print(f'{len(rinkdata)=} found')
  celldata  = tx.dataV2(celldata) # convert YAML to layered rows
  nrc, geom = cd2.geometry(rinkid, celldata)
  print(f'geom {nrc} new records') if nrc else print(f'{len(geom)=} found')
  nrc, stk = cd2.strokes(rinkid, rinkdata[2], celldata)
  print(f' stk {nrc} new records') if nrc else print(f'{len(stk)=} found')
  nrc, pal = cd2.palette(rinkid, rinkdata[2], celldata)
  print(f' pal {nrc} new records') if nrc else print(f'{len(pal)=} found')
  '''
  '''

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
def build(args):
  ''' generate an SVG from tmpfile or an HTML palette
  '''
  if args.output is None:  # or args.layer is None:      
    print('check input e.g. -o gives defaul value = db1')
  else:                       
    buildOut(args.model, args.output) #, args.layer)

def buildOut(model, output, size=90, factor=1):
  layer     = 3
  svglin    = SvgModel(size, factor)
  bd        = BlockData(model)
  positions = bd.readPositions(model)
  
  celldata  = tf.readConf(model)
  oldver    = fnam.index(tf.VERSION)
  #penam     = bd.penNames(ver)
  ''' validate depends on hex values from existing rinks
      a new pen always fails
      this can be fixed once db2 is live
  '''
  # view.validate(celldata, ver=ver)
  block     = Make(size, linear=False) # , pen_names=penam)
  block.walk(positions, celldata, z=layer)

  svgfile   = f'{model}_{output}'
  block.hydrateGrid()
  svglin.build(block)
  svglin.render(svgfile, line=False)
  print(f'tmp/{svgfile} was built with {oldver=}')

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
def __build():
  if False:
    ###########################  

    svgfile   = model + '_exchange'
    svg       = SvgModel(18) # size of preview palswap.svg
    block     = Make(18, linear=False)
    # start to build
    block.walk(positions, celldata)
    block.hydrateGrid()
    svg.build(block)
    svg.render(svgfile, line=False)
    print(f'tmp/{svgfile}.svg was built')
  elif args.model and args.size and args.factor:
    raise Warning(f'''missing argument
{args.palette=} 
{args.digest=}
{args.model=} 
{args.size=}
{args.factor=}
''')

def renderSwap(mdl, ver, positions):
  DEPTH     = 2  # swap to 3 to walk through all layers
  celldata  = tf.readConf(mdl)
  view.validate(celldata, ver=ver)
  svgfile   = mdl + '_palswap'
  svg       = SvgModel(90) # size of preview palswap.svg
  block     = Make(90, linear=False)
  # start to build
  block.walk(positions, celldata, z=DEPTH)
  block.hydrateGrid()
  svg.build(block)
  svg.render(svgfile, line=False)
  print(f'tmp/{svgfile}.svg was built')

def __clonePal():
  positions = bd.readPositions(model)
  ver       = args.palette # use onlyi pen pals 8..12 please
  tf.setVersion(ver)
  oc        = tf.getOldColors(dig)
  pal.loadPalette(ver=ver)     # merge fg bg stroke into uniqfill 
  nc        = pmk.setLookUp(pal.uniqfill) # for search the new colour
  swp       = pmk.swapColors(oc, nc)
  print(f'''{len(oc)} to swap
{len(nc)} to search
''')
  pp.pprint(swp)
  celldata  = pmk.updateCells(celldata, swp)
  tf.write(model, args.digest, celldata)   # new colors to conf/palswap.yaml

def __getOldColors(dig):
  ''' read old colours from palettes/DIGEST.txt

  to generate palettes/DIGEST.txt as list of colour from rink to swap
  ./recurrink clone -d2fcb3c6c178814262c116e16b62c6a19 -opal
  '''
  oc  = set()
  old_pal = tf.importPalfile(dig)
  [oc.add(c[0]) for c in old_pal]
  [oc.add(c[2]) for c in old_pal]
  return oc



''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
if __name__ == "__main__":
  args = main(sys.argv[1:])
  if   args.keyword == 'init':    init(args)
  elif args.keyword == 'clone':   clone(args)
  elif args.keyword == 'build':   build(args)
  elif args.keyword == 'commit':  commit(args)
  else:
    print(f'usage: {sys.argv[0]} --help')
    sys.exit(1)
'''
the
end
'''
